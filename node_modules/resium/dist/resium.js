var _e = Object.defineProperty;
var Oe = (i, e, t) => e in i ? _e(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var I = (i, e, t) => (Oe(i, typeof e != "symbol" ? e + "" : e, t), t);
import Ae, { createContext as Be, useContext as Ge, useRef as R, useEffect as K, useState as Me, useCallback as oe, useLayoutEffect as Ie, useImperativeHandle as Fe, forwardRef as ke, useMemo as Ve } from "react";
import { ScreenSpaceEventType as P, ScreenSpaceEventHandler as $e, Event as ye, BillboardCollection as Ue, BillboardGraphics as We, BoxGraphics as je, Cesium3DTileset as He, Cesium3DTilesetGraphics as Ne, Cesium3DTilesTerrainProvider as pe, CesiumWidget as ze, ClassificationPrimitive as xe, CloudCollection as qe, CorridorGraphics as Ye, CustomDataSource as Ke, CylinderGraphics as Je, CzmlDataSource as Ze, EllipseGraphics as Xe, EllipsoidGraphics as Qe, Entity as ei, Fog as ge, GeoJsonDataSource as ii, Google2DImageryProvider as ve, GroundPolylinePrimitive as ti, GroundPrimitive as ni, ImageryLayer as oi, KmlDataSource as ri, LabelCollection as si, LabelGraphics as ai, Model as li, ModelGraphics as ci, Moon as Ce, ParticleSystem as ui, PathGraphics as di, PlaneGraphics as mi, PointGraphics as hi, PointPrimitiveCollection as fi, PolygonGraphics as yi, PolylineCollection as pi, PolylineGraphics as gi, PolylineVolumeGraphics as vi, PostProcessStage as Ci, PostProcessStageLibrary as V, PostProcessStageComposite as Pi, Primitive as Ei, RectangleGraphics as wi, SceneMode as ue, Sun as Pe, TimeDynamicPointCloud as Si, Viewer as bi, WallGraphics as Di } from "cesium";
import { createPortal as Ri } from "react-dom";
const fe = Be({}), { Provider: Qn, Consumer: Ti } = fe, ae = () => Ge(fe) || {}, le = (i, e) => {
  const t = (n) => {
    const o = ae(), s = R(void 0), l = R(!1);
    return K(() => () => {
      o.camera && n.cancelFlightOnUnmount && o.camera.cancelFlight();
    }, [o.camera, n.cancelFlightOnUnmount]), K(() => {
      o.camera && o.scene && !o.scene.isDestroyed() && (!n.once || !l.current) && (o.camera.cancelFlight(), e(o.camera, n, s.current), l.current = !0), s.current = n;
    }), null;
  };
  return t.displayName = i, t;
};
var de = { exports: {} }, ee = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ee;
function Mi() {
  if (Ee)
    return ee;
  Ee = 1;
  var i = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
  function t(n, o, s) {
    var l = null;
    if (s !== void 0 && (l = "" + s), o.key !== void 0 && (l = "" + o.key), "key" in o) {
      s = {};
      for (var m in o)
        m !== "key" && (s[m] = o[m]);
    } else
      s = o;
    return o = s.ref, {
      $$typeof: i,
      type: n,
      key: l,
      ref: o !== void 0 ? o : null,
      props: s
    };
  }
  return ee.Fragment = e, ee.jsx = t, ee.jsxs = t, ee;
}
var ie = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var we;
function ki() {
  return we || (we = 1, process.env.NODE_ENV !== "production" && function() {
    function i(r) {
      if (r == null)
        return null;
      if (typeof r == "function")
        return r.$$typeof === X ? null : r.displayName || r.name || null;
      if (typeof r == "string")
        return r;
      switch (r) {
        case B:
          return "Fragment";
        case _:
          return "Profiler";
        case L:
          return "StrictMode";
        case J:
          return "Suspense";
        case z:
          return "SuspenseList";
        case W:
          return "Activity";
      }
      if (typeof r == "object")
        switch (typeof r.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), r.$$typeof) {
          case G:
            return "Portal";
          case ne:
            return r.displayName || "Context";
          case U:
            return (r._context.displayName || "Context") + ".Consumer";
          case N:
            var u = r.render;
            return r = r.displayName, r || (r = u.displayName || u.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
          case Z:
            return u = r.displayName || null, u !== null ? u : i(r.type) || "Memo";
          case M:
            u = r._payload, r = r._init;
            try {
              return i(r(u));
            } catch {
            }
        }
      return null;
    }
    function e(r) {
      return "" + r;
    }
    function t(r) {
      try {
        e(r);
        var u = !1;
      } catch {
        u = !0;
      }
      if (u) {
        u = console;
        var c = u.error, g = typeof Symbol == "function" && Symbol.toStringTag && r[Symbol.toStringTag] || r.constructor.name || "Object";
        return c.call(
          u,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          g
        ), e(r);
      }
    }
    function n(r) {
      if (r === B)
        return "<>";
      if (typeof r == "object" && r !== null && r.$$typeof === M)
        return "<...>";
      try {
        var u = i(r);
        return u ? "<" + u + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function o() {
      var r = j.A;
      return r === null ? null : r.getOwner();
    }
    function s() {
      return Error("react-stack-top-frame");
    }
    function l(r) {
      if (x.call(r, "key")) {
        var u = Object.getOwnPropertyDescriptor(r, "key").get;
        if (u && u.isReactWarning)
          return !1;
      }
      return r.key !== void 0;
    }
    function m(r, u) {
      function c() {
        C || (C = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          u
        ));
      }
      c.isReactWarning = !0, Object.defineProperty(r, "key", {
        get: c,
        configurable: !0
      });
    }
    function d() {
      var r = i(this.type);
      return w[r] || (w[r] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), r = this.props.ref, r !== void 0 ? r : null;
    }
    function f(r, u, c, g, O, H) {
      var y = c.ref;
      return r = {
        $$typeof: E,
        type: r,
        key: u,
        props: c,
        _owner: g
      }, (y !== void 0 ? y : null) !== null ? Object.defineProperty(r, "ref", {
        enumerable: !1,
        get: d
      }) : Object.defineProperty(r, "ref", { enumerable: !1, value: null }), r._store = {}, Object.defineProperty(r._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(r, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(r, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: O
      }), Object.defineProperty(r, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: H
      }), Object.freeze && (Object.freeze(r.props), Object.freeze(r)), r;
    }
    function p(r, u, c, g, O, H) {
      var y = u.children;
      if (y !== void 0)
        if (g)
          if (Q(y)) {
            for (g = 0; g < y.length; g++)
              D(y[g]);
            Object.freeze && Object.freeze(y);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else
          D(y);
      if (x.call(u, "key")) {
        y = i(r);
        var q = Object.keys(u).filter(function(Le) {
          return Le !== "key";
        });
        g = 0 < q.length ? "{key: someKey, " + q.join(": ..., ") + ": ...}" : "{key: someKey}", S[y + g] || (q = 0 < q.length ? "{" + q.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          g,
          y,
          q,
          y
        ), S[y + g] = !0);
      }
      if (y = null, c !== void 0 && (t(c), y = "" + c), l(u) && (t(u.key), y = "" + u.key), "key" in u) {
        c = {};
        for (var ce in u)
          ce !== "key" && (c[ce] = u[ce]);
      } else
        c = u;
      return y && m(
        c,
        typeof r == "function" ? r.displayName || r.name || "Unknown" : r
      ), f(
        r,
        y,
        c,
        o(),
        O,
        H
      );
    }
    function D(r) {
      T(r) ? r._store && (r._store.validated = 1) : typeof r == "object" && r !== null && r.$$typeof === M && (r._payload.status === "fulfilled" ? T(r._payload.value) && r._payload.value._store && (r._payload.value._store.validated = 1) : r._store && (r._store.validated = 1));
    }
    function T(r) {
      return typeof r == "object" && r !== null && r.$$typeof === E;
    }
    var h = Ae, E = Symbol.for("react.transitional.element"), G = Symbol.for("react.portal"), B = Symbol.for("react.fragment"), L = Symbol.for("react.strict_mode"), _ = Symbol.for("react.profiler"), U = Symbol.for("react.consumer"), ne = Symbol.for("react.context"), N = Symbol.for("react.forward_ref"), J = Symbol.for("react.suspense"), z = Symbol.for("react.suspense_list"), Z = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), W = Symbol.for("react.activity"), X = Symbol.for("react.client.reference"), j = h.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, x = Object.prototype.hasOwnProperty, Q = Array.isArray, v = console.createTask ? console.createTask : function() {
      return null;
    };
    h = {
      react_stack_bottom_frame: function(r) {
        return r();
      }
    };
    var C, w = {}, b = h.react_stack_bottom_frame.bind(
      h,
      s
    )(), k = v(n(s)), S = {};
    ie.Fragment = B, ie.jsx = function(r, u, c) {
      var g = 1e4 > j.recentlyCreatedOwnerStacks++;
      return p(
        r,
        u,
        c,
        !1,
        g ? Error("react-stack-top-frame") : b,
        g ? v(n(r)) : k
      );
    }, ie.jsxs = function(r, u, c) {
      var g = 1e4 > j.recentlyCreatedOwnerStacks++;
      return p(
        r,
        u,
        c,
        !0,
        g ? Error("react-stack-top-frame") : b,
        g ? v(n(r)) : k
      );
    };
  }()), ie;
}
process.env.NODE_ENV === "production" ? de.exports = Mi() : de.exports = ki();
var A = de.exports;
function $i(i, e) {
  return e ? me(i).reduce(
    (t, [n, o]) => (te(e, n) && (t[n] = o), t),
    {}
  ) : {};
}
function me(i) {
  return Object.keys(i).map((e) => [e, i[e]]);
}
function te(i, e) {
  return !!i && i.indexOf(e) !== -1;
}
function Li(i, e) {
  return !!i && !!e && [...Object.keys(i), ...Object.keys(e)].every((t) => i[t] === e[t]);
}
function _i(i) {
  return i && typeof i.isDestroyed == "function" && typeof i.destroy == "function";
}
function Oi(i) {
  return _i(i) && i.isDestroyed();
}
function F(i) {
  return i && typeof i == "object" && "then" in i && typeof i.then == "function";
}
const Y = "__RESIUM_EVENT_MANAGER", he = [
  "onClick",
  "onDoubleClick",
  "onMouseDown",
  "onMouseUp",
  "onMiddleClick",
  "onMiddleDown",
  "onMiddleUp",
  "onMouseMove",
  "onPinchEnd",
  "onPinchMove",
  "onPinchStart",
  "onRightClick",
  "onRightDown",
  "onRightUp",
  "onWheel",
  "onMouseEnter",
  "onMouseLeave"
], se = class se {
  constructor(e) {
    I(this, "scene");
    I(this, "sshe");
    I(this, "events", {
      onClick: /* @__PURE__ */ new Map(),
      onDoubleClick: /* @__PURE__ */ new Map(),
      onMouseDown: /* @__PURE__ */ new Map(),
      onMouseUp: /* @__PURE__ */ new Map(),
      onMiddleClick: /* @__PURE__ */ new Map(),
      onMiddleDown: /* @__PURE__ */ new Map(),
      onMiddleUp: /* @__PURE__ */ new Map(),
      onMouseMove: /* @__PURE__ */ new Map(),
      onPinchEnd: /* @__PURE__ */ new Map(),
      onPinchMove: /* @__PURE__ */ new Map(),
      onPinchStart: /* @__PURE__ */ new Map(),
      onRightClick: /* @__PURE__ */ new Map(),
      onRightDown: /* @__PURE__ */ new Map(),
      onRightUp: /* @__PURE__ */ new Map(),
      onWheel: /* @__PURE__ */ new Map(),
      onMouseEnter: /* @__PURE__ */ new Map(),
      onMouseLeave: /* @__PURE__ */ new Map()
    });
    I(this, "hovered");
    I(this, "onMouseMove", (e) => {
      var n, o, s, l, m, d;
      const t = this.pick(e.endPosition);
      this.hovered !== t && (this.hovered && ((n = this.getEventCallback("onMouseLeave", this.hovered)) == null || n(e, this.hovered), (o = this.getEventCallback("onMouseLeave", null)) == null || o(e, this.hovered)), t && ((s = this.getEventCallback("onMouseEnter", t)) == null || s(e, t), (l = this.getEventCallback("onMouseEnter", null)) == null || l(e, t))), t && ((m = this.getEventCallback("onMouseMove", t)) == null || m(e, t)), (d = this.getEventCallback("onMouseMove", null)) == null || d(e, t), this.hovered = t;
    });
    I(this, "eventCallback", (e) => (t) => {
      var o, s;
      const n = this.pick(t == null ? void 0 : t.position);
      n && ((o = this.getEventCallback(e, n)) == null || o(t, n)), (s = this.getEventCallback(e, null)) == null || s(t, n);
    });
    this.scene = e, this.sshe = new $e(e == null ? void 0 : e.canvas);
  }
  destroy() {
    this.hovered = void 0, this.sshe.isDestroyed() || this.sshe.destroy();
  }
  isDestroyed() {
    return this.sshe.isDestroyed();
  }
  on(e, t, n) {
    e && t === "onWheel" || this.events[t].set(e, n);
  }
  off(e, t) {
    this.events[t].delete(e), this.hovered === e && (this.hovered = void 0);
  }
  setEvents(e, t) {
    me(t).forEach(([n, o]) => {
      const s = n;
      te(he, s) && (o ? this.on(e, s, o) : this.off(e, s));
    }), this.commit();
  }
  clearEvents(e) {
    this.hovered = void 0, he.forEach((t) => {
      this.off(e, t);
    }), this.commit();
  }
  commit() {
    const e = this.sshe, t = this.sshe.isDestroyed();
    t || (this.events.onMouseEnter.size === 0 && this.events.onMouseLeave.size === 0 && this.events.onMouseMove.size === 0 ? this.sshe.removeInputAction(P.MOUSE_MOVE) : this.sshe.getInputAction(P.MOUSE_MOVE) || this.sshe.setInputAction(this.onMouseMove, P.MOUSE_MOVE)), me(this.events).forEach(([n, o]) => {
      if (n === "onMouseEnter" || n === "onMouseLeave" || n === "onMouseMove")
        return;
      const s = se.eventTypeMap[n];
      t || (o.size === 0 ? e.removeInputAction(s) : e.getInputAction(s) || e.setInputAction(this.eventCallback(n), s));
    });
  }
  getScreenSpaceEventHandler() {
    return this.sshe;
  }
  getEventCallback(e, t) {
    var n, o;
    return t === null ? this.events[e].get(null) : this.events[e].get(t.id) || // Entity
    this.events[e].get((o = (n = t.id) == null ? void 0 : n.entityCollection) == null ? void 0 : o.owner) || // Entity in DataSource
    this.events[e].get(t.primitive) || // Primitive
    this.events[e].get(t.tileset);
  }
  pick(e) {
    var t;
    if (e)
      return (t = this.scene) == null ? void 0 : t.pick(e);
  }
};
I(se, "eventTypeMap", {
  onClick: P.LEFT_CLICK,
  onDoubleClick: P.LEFT_DOUBLE_CLICK,
  onMouseDown: P.LEFT_DOWN,
  onMouseUp: P.LEFT_UP,
  onMiddleClick: P.MIDDLE_CLICK,
  onMiddleDown: P.MIDDLE_DOWN,
  onMiddleUp: P.MIDDLE_UP,
  onMouseMove: P.MOUSE_MOVE,
  onPinchEnd: P.PINCH_END,
  onPinchMove: P.PINCH_MOVE,
  onPinchStart: P.PINCH_START,
  onRightClick: P.RIGHT_CLICK,
  onRightDown: P.RIGHT_DOWN,
  onRightUp: P.RIGHT_UP,
  onWheel: P.WHEEL,
  onMouseEnter: P.MOUSE_MOVE,
  onMouseLeave: P.MOUSE_MOVE
});
let re = se;
const Ai = ({
  name: i,
  create: e,
  destroy: t,
  provide: n,
  update: o,
  cesiumReadonlyProps: s,
  cesiumEventProps: l,
  otherProps: m,
  setCesiumPropsAfterCreate: d,
  useCommonEvent: f,
  useRootEvent: p
}, D, T) => {
  const h = R(void 0), E = ae(), G = R(n ? {} : void 0), B = R({}), L = R(Se(D)), _ = R({}), [U, ne] = Me(!1), N = R(!1), J = R(null), z = R(void 0), Z = E == null ? void 0 : E[Y], M = R(void 0), W = R(void 0), X = oe(
    async (v) => {
      var u;
      if (!h.current)
        return;
      const C = h.current, w = Object.keys(v), b = Object.keys(l || []), k = w.concat(
        Object.keys(_.current).filter((c) => !w.includes(c))
      ).filter((c) => _.current[c] !== v[c]).map((c) => [c, _.current[c], v[c]]), S = [];
      for (const [c, g, O] of k)
        if (s != null && s.includes(c))
          S.push(c);
        else if (te(b, c)) {
          const H = l == null ? void 0 : l[c], y = C[H];
          y instanceof ye && (typeof g > "u" ? (y.addEventListener(O), B.current[H] = O) : typeof O > "u" ? (y.removeEventListener(g), delete B.current[H]) : (y.removeEventListener(g), y.addEventListener(O)));
        } else
          c !== "children" && !he.includes(c) && !(m != null && m.includes(c)) && (C[c] = O);
      const r = p ? (u = G.current) == null ? void 0 : u[Y] : Z;
      if (f && r && h.current && r.setEvents(p ? null : h.current, v), o && N.current) {
        const c = o(h.current, v, _.current, E);
        F(c) && await c;
      }
      _.current = v, L.current = v, N.current && S.length > 0 && (process.env.NODE_ENV !== "production" && console.warn(
        `Warning: <${i}> is recreated because following read-only props have been updated: ${S.join(
          ", "
        )}`
      ), x(), await Q(), M.current = j());
    },
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  ), j = oe(async () => {
    var b;
    await new Promise((k) => queueMicrotask(() => k(void 0)));
    const v = e == null ? void 0 : e(E, L.current, J.current);
    let C;
    if (F(v) ? C = await v : C = v, Array.isArray(C) ? (h.current = C[0], z.current = C[1]) : h.current = C, d)
      await X(L.current);
    else {
      if (h.current && l) {
        const k = h.current;
        for (const S of Object.keys(L.current)) {
          const r = l[S];
          if (r) {
            const u = L.current[S], c = k[r];
            u && c instanceof ye && c.addEventListener(u);
          }
        }
      }
      _.current = L.current;
    }
    n && h.current && (G.current = {
      ...E,
      ...n(h.current, E, D, z.current)
    });
    const w = p ? (b = G.current) == null ? void 0 : b[Y] : Z;
    f && w && h.current && w.setEvents(p ? null : h.current, L.current), W.current || ne(!0);
  }, []), x = oe(() => {
    ne(!1), N.current = !1;
  }, []), Q = oe(async () => {
    var C, w;
    await new Promise((b) => queueMicrotask(() => b(void 0))), M.current && (await M.current, M.current = void 0), h.current && t && t(h.current, E, J.current, z.current);
    const v = p ? (C = G.current) == null ? void 0 : C[Y] : Z;
    if (f && v && h.current && v.clearEvents(p ? null : h.current), h.current && !Oi(h.current)) {
      const b = Object.keys(B.current);
      for (const k of b) {
        const S = h.current[k];
        (w = S == null ? void 0 : S.removeEventListener) == null || w.call(S, B.current[k]);
      }
    }
    B.current = {}, G.current = void 0, z.current = void 0, h.current = void 0;
  }, []);
  return Ie(() => ((async () => {
    W.current && (await W.current, W.current = void 0), M.current = j();
  })(), () => {
    x(), W.current = Q();
  }), [j, Q, x]), K(() => {
    (async () => {
      var w, b;
      M.current && await M.current;
      const C = Se(D);
      U ? Li(C, _.current) || (await X(C), (b = (w = E.__$internal) == null ? void 0 : w.onUpdate) == null || b.call(w)) : (_.current = C, L.current = C, N.current = !0);
    })();
  }, [E.__$internal, U, D, X]), Fe(
    T,
    () => ({
      cesiumElement: U ? h.current : null
    }),
    [U]
  ), [G.current, U, J];
};
function Se(i) {
  const { children: e, ...t } = i;
  return t;
}
const a = ({
  renderContainer: i,
  noChildren: e,
  containerProps: t,
  defaultProps: n,
  ...o
}) => {
  const s = (l, m) => {
    const d = {
      ...n,
      ...l
    }, [f, p, D] = Ai(
      o,
      d,
      m
    );
    if (e)
      return null;
    const T = p && "children" in d ? d.children : null, h = i ? /* @__PURE__ */ A.jsx(
      "div",
      {
        "data-testid": "resium-container",
        ref: D,
        ...typeof t == "function" ? t(d) : $i(d, t),
        children: T
      }
    ) : T ? /* @__PURE__ */ A.jsx(A.Fragment, { children: T }) : null;
    return f ? /* @__PURE__ */ A.jsx(fe.Provider, { value: f, children: h }) : h;
  };
  return s.displayName = o.name, ke(s);
}, Bi = ["enabled", "selected"], $ = (i) => a({
  name: i.name,
  create(e, t) {
    if (!e.scene)
      return;
    const n = i.create(t, e.scene.postProcessStages);
    return typeof t.enabled == "boolean" && (n.enabled = t.enabled), t.selected && "selected" in n && (n.selected = t.selected), i.props.forEach((o) => {
      !te(i.readonlyProps, o) && typeof t[o] < "u" && (n.uniforms[o] = t[o]);
    }), !i.noMount && e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.add(n), n;
  },
  destroy(e, t) {
    i.noMount ? e.enabled = !1 : (t.scene && !t.scene.isDestroyed() && t.scene.postProcessStages.remove(e), e.isDestroyed() || e.destroy());
  },
  update(e, t, n) {
    i.props.forEach((o) => {
      !te(i.readonlyProps, o) && t[o] !== n[o] && (e.uniforms[o] = t[o]);
    });
  },
  cesiumProps: Bi,
  cesiumReadonlyProps: i.readonlyProps,
  defaultProps: {
    enabled: !0
  }
}), eo = (i) => (
  // supports both functional components and class components
  ke((e, t) => /* @__PURE__ */ A.jsx(Ti, { children: (n) => /* @__PURE__ */ A.jsx(i, { ...e, ref: t, cesium: n }) }))
), Gi = [
  "alignedAxis",
  "color",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "eyeOffset",
  "height",
  "heightReference",
  "horizontalOrigin",
  "image",
  "pixelOffset",
  "pixelOffsetScaleByDistance",
  "position",
  "rotation",
  "scale",
  "scaleByDistance",
  "show",
  "sizeInMeters",
  "splitDirection",
  "translucencyByDistance",
  "verticalOrigin",
  "width",
  "id"
], io = a({
  name: "Billboard",
  create(i, e) {
    var t;
    return (t = i.billboardCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.billboardCollection && !e.billboardCollection.isDestroyed() && e.billboardCollection.remove(i);
  },
  cesiumProps: Gi,
  useCommonEvent: !0
}), Ii = [
  "blendOption",
  "debugShowBoundingVolume",
  "debugShowTextureAtlas",
  "modelMatrix",
  "show"
], to = a({
  name: "BillboardCollection",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const t = new Ue({
      modelMatrix: e.modelMatrix,
      debugShowBoundingVolume: e.debugShowBoundingVolume,
      scene: i.scene,
      blendOption: e.blendOption
    });
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      billboardCollection: i
    };
  },
  cesiumProps: Ii
}), Fi = [
  "image",
  "show",
  "scale",
  "horizontalOrigin",
  "verticalOrigin",
  "eyeOffset",
  "pixelOffset",
  "rotation",
  "alignedAxis",
  "width",
  "height",
  "color",
  "scaleByDistance",
  "translucencyByDistance",
  "pixelOffsetScaleByDistance",
  "imageSubRegion",
  "sizeInMeters",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance",
  "splitDirection"
], Vi = {
  onDefinitionChange: "definitionChanged"
}, no = a({
  name: "BillboardGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new We(e);
    return i.entity.billboard = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.billboard = void 0);
  },
  cesiumProps: Fi,
  cesiumEventProps: Vi
}), Ui = [
  "heightReference",
  "dimensions",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "shadows",
  "distanceDisplayCondition"
], Wi = {
  onDefinitionChange: "definitionChanged"
}, oo = a({
  name: "BoxGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new je(e);
    return i.entity.box = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.box = void 0);
  },
  cesiumProps: Ui,
  cesiumEventProps: Wi
}), ji = [
  "position",
  "direction",
  "up",
  "right",
  "frustum",
  "defaultMoveAmount",
  "defaultLookAmount",
  "defaultRotateAmount",
  "defaultZoomAmount",
  "constrainedAxis",
  "maximumZoomFactor",
  "percentageChanged"
], Hi = {
  onChange: "changed",
  onMoveEnd: "moveEnd",
  onMoveStart: "moveStart"
}, ro = a({
  name: "Camera",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.camera;
  },
  cesiumProps: ji,
  cesiumEventProps: Hi,
  setCesiumPropsAfterCreate: !0
}), so = le(
  "CameraFlyHome",
  (i, { duration: e }) => {
    i.flyHome(e);
  }
), ao = le(
  "CameraFlyTo",
  (i, { onComplete: e, onCancel: t, ...n }) => {
    i.flyTo({ ...n, complete: e, cancel: t });
  }
), lo = le(
  "CameraLookAt",
  (i, { target: e, offset: t }) => {
    i.lookAt(e, t);
  }
), co = le(
  "CameraFlyToBoundingSphere",
  (i, { boundingSphere: e, onComplete: t, onCancel: n, ...o }) => {
    i.flyToBoundingSphere(e, {
      ...o,
      complete: t,
      cancel: n
    });
  }
), Ni = [
  "show",
  "modelMatrix",
  "shadows",
  "maximumScreenSpaceError",
  "cullRequestsWhileMoving",
  "cullRequestsWhileMovingMultiplier",
  "preloadWhenHidden",
  "preloadFlightDestinations",
  "preferLeaves",
  "progressiveResolutionHeightFraction",
  "foveatedScreenSpaceError",
  "foveatedConeSize",
  "foveatedMinimumScreenSpaceErrorRelaxation",
  "foveatedInterpolationCallback",
  "foveatedTimeDelay",
  "dynamicScreenSpaceError",
  "dynamicScreenSpaceErrorDensity",
  "dynamicScreenSpaceErrorFactor",
  "dynamicScreenSpaceErrorHeightFalloff",
  "skipLevelOfDetail",
  "baseScreenSpaceError",
  "skipScreenSpaceErrorFactor",
  "skipLevels",
  "immediatelyLoadDesiredLevelOfDetail",
  "loadSiblings",
  "clippingPlanes",
  "clippingPolygons",
  "lightColor",
  "colorBlendAmount",
  "colorBlendMode",
  "debugFreezeFrame",
  "debugColorizeTiles",
  "debugWireframe",
  "debugShowBoundingVolume",
  "debugShowContentBoundingVolume",
  "debugShowViewerRequestVolume",
  "debugShowGeometricError",
  "debugShowRenderingStatistics",
  "debugShowMemoryUsage",
  "debugShowUrl",
  "style",
  "backFaceCulling",
  "showOutline",
  "vectorClassificationOnly",
  "vectorKeepDecodedPositions",
  "splitDirection",
  "customShader",
  "imageBasedLighting",
  "showCreditsOnScreen",
  "featureIdLabel",
  "instanceFeatureIdLabel",
  "outlineColor",
  "cacheBytes",
  "maximumCacheOverflowBytes",
  "enableCollision"
], zi = [
  "asynchronouslyLoadImagery",
  "classificationType",
  "cullWithChildrenBounds",
  "debugHeatmapTilePropertyName",
  "ellipsoid",
  "enableDebugWireframe",
  "heightReference",
  "modelUpAxis",
  "modelForwardAxis",
  "projectTo2D",
  "enableShowOutline",
  "enablePick",
  "environmentMapOptions",
  "scene"
], xi = {
  onAllTilesLoad: "allTilesLoaded",
  onInitialTilesLoad: "initialTilesLoaded",
  onLoadProgress: "loadProgress",
  onTileFailed: "tileFailed",
  onTileLoad: "tileLoad",
  onTileUnload: "tileUnload",
  onTileVisible: "tileVisible"
}, qi = ["onReady", "onError", "url"], uo = a({
  name: "Cesium3DTileset",
  async create(i, e) {
    var s, l;
    if (!i.primitiveCollection)
      return;
    const t = e.url;
    let n;
    F(t) ? n = await t : n = t;
    let o;
    try {
      o = await He.fromUrl(n, e), (s = e.onReady) == null || s.call(e, o);
    } catch (m) {
      (l = e.onError) == null || l.call(e, m);
      return;
    }
    return e.colorBlendAmount && (o.colorBlendAmount = e.colorBlendAmount), e.colorBlendMode && (o.colorBlendMode = e.colorBlendMode), e.style && (o.style = e.style), i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Ni,
  cesiumReadonlyProps: zi,
  cesiumEventProps: xi,
  otherProps: qi,
  useCommonEvent: !0
}), Yi = ["show", "uri", "maximumScreenSpaceError"], Ki = {
  onDefinitionChange: "definitionChanged"
}, mo = a({
  name: "Cesium3DTilesetGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Ne(e);
    return i.entity.tileset = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.tileset = void 0);
  },
  cesiumProps: Yi,
  cesiumEventProps: Ki
}), ho = a({
  name: "Cesium3DTilesTerrainProvider",
  async create(i, e) {
    const { onReady: t, assetId: n, accessToken: o, url: s, children: l, ...m } = e;
    let d;
    if (n !== void 0)
      d = await pe.fromIonAssetId(
        n,
        m
      );
    else if (s !== void 0)
      d = await pe.fromUrl(s, m);
    else
      throw new Error(
        "Cesium3DTilesTerrainProvider requires either 'url' or 'assetId' prop to be provided"
      );
    return t && t(d), d;
  }
}), Ji = [
  "resolutionScale",
  "useDefaultRenderLoop",
  "targetFrameRate",
  "useBrowserRecommendedResolution",
  "allowDataSourcesToSuspendAnimation",
  "trackedEntity",
  "clockTrackedDataSource",
  "terrainProvider",
  "creditDisplay"
], Zi = [
  "clock",
  "shouldAnimate",
  "ellipsoid",
  "baseLayer",
  "skyBox",
  "skyAtmosphere",
  "sceneMode",
  "scene3DOnly",
  "orderIndependentTranslucency",
  "mapMode2D",
  "mapProjection",
  "globe",
  "showRenderLoopErrors",
  "automaticallyTrackDataSourceClocks",
  "contextOptions",
  "creditContainer",
  "creditViewport",
  "dataSources",
  "shadows",
  "terrainShadows",
  "terrain",
  "requestRenderMode",
  "maximumRenderTimeChange",
  "msaaSamples",
  "blurActiveElementOnCanvasFocus"
], Xi = ["className", "id", "style", "full", "containerProps"], fo = a({
  name: "CesiumWidget",
  create(i, e, t) {
    if (!t)
      return;
    const n = new ze(t, e);
    if (!n)
      return;
    typeof e.resolutionScale == "number" && (n.resolutionScale = e.resolutionScale);
    const o = new re(n.scene);
    return [n, o];
  },
  destroy(i, e, t, n) {
    n && !n.isDestroyed() && n.destroy(), i.isDestroyed() || i.destroy();
  },
  provide(i, e, t, n) {
    return {
      cesiumWidget: i,
      scene: i.scene,
      camera: i.scene.camera,
      imageryLayerCollection: i.scene.globe.imageryLayers,
      primitiveCollection: i.scene.primitives,
      globe: i.scene.globe,
      __$internal: {
        onUpdate: t == null ? void 0 : t.onUpdate
      },
      [Y]: n
    };
  },
  containerProps: ({ id: i, className: e, style: t, full: n, containerProps: o }) => ({
    className: e,
    id: i,
    style: {
      ...n ? {
        position: "absolute",
        bottom: "0",
        left: "0",
        right: "0",
        top: "0"
      } : {},
      ...t
    },
    ...o
  }),
  cesiumProps: Ji,
  cesiumReadonlyProps: Zi,
  otherProps: Xi,
  renderContainer: !0,
  useCommonEvent: !0,
  useRootEvent: !0
}), Qi = [
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], et = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize",
  "appearance"
], it = ["onReady"], yo = a({
  name: "ClassificationPrimitive",
  async create(i, e) {
    var n;
    if (!i.primitiveCollection)
      return;
    const t = new xe(e);
    if (e.onReady) {
      const o = () => {
        var s, l;
        t.ready && ((s = e.onReady) == null || s.call(e, t), (l = i.scene) == null || l.postRender.removeEventListener(o));
      };
      (n = i.scene) == null || n.postRender.addEventListener(o);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Qi,
  cesiumReadonlyProps: et,
  otherProps: it,
  useCommonEvent: !0
}), tt = {
  onStop: "onStop",
  onTick: "onTick"
}, nt = [
  "canAnimate",
  "clockRange",
  "clockStep",
  "currentTime",
  "multiplier",
  "shouldAnimate",
  "startTime",
  "stopTime"
], po = a({
  name: "Clock",
  create: (i) => {
    var e;
    return (e = i.cesiumWidget) == null ? void 0 : e.clock;
  },
  cesiumProps: nt,
  cesiumEventProps: tt,
  setCesiumPropsAfterCreate: !0
}), ot = [
  "noiseDetail",
  "noiseOffset",
  "show",
  "debugBillboards",
  "debugEllipsoids"
], go = a({
  name: "CloudCollection",
  create: (i) => {
    if (!i.primitiveCollection)
      return;
    const e = new qe();
    return i.primitiveCollection.add(e), e;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide: (i) => ({
    cloudCollection: i
  }),
  cesiumProps: ot,
  setCesiumPropsAfterCreate: !0
}), rt = [
  "positions",
  "width",
  "cornerType",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType"
], st = {
  onDefinitionChange: "definitionChanged"
}, vo = a({
  name: "CorridorGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Ye(e);
    return e.classificationType && (t.classificationType = e.classificationType), i.entity.corridor = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.corridor = void 0);
  },
  cesiumProps: rt,
  cesiumEventProps: st
}), at = [
  "show",
  "position",
  "scale",
  "maximumSize",
  "slice",
  "brightness",
  "color"
], Co = a({
  name: "CumulusCloud",
  create: (i, e) => {
    var t;
    return (t = i.cloudCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.cloudCollection && !e.cloudCollection.isDestroyed() && e.cloudCollection.remove(i);
  },
  cesiumProps: at
}), lt = ["clustering", "name", "show", "clock", "isLoading"], ct = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, Po = a({
  name: "CustomDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const t = new Ke(e.name);
    return e.clustering && (t.clustering = e.clustering), typeof e.show == "boolean" && (t.show = e.show), typeof e.clock < "u" && (t.clock = e.clock), i.dataSourceCollection.add(t), t;
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      entityCollection: i.entities,
      dataSource: i
    };
  },
  cesiumProps: lt,
  cesiumEventProps: ct,
  useCommonEvent: !0
}), ut = [
  "heightReference",
  "length",
  "topRadius",
  "bottomRadius",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "numberOfVerticalLines",
  "slices",
  "distanceDisplayCondition",
  "shadows"
], dt = {
  onDefinitionChange: "definitionChanged"
}, Eo = a({
  name: "CylinderGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Je(e);
    return i.entity.cylinder = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.cylinder = void 0);
  },
  cesiumProps: ut,
  cesiumEventProps: dt
}), mt = ["clustering", "show"], ht = ["name", "sourceUri", "credit"], ft = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, yt = ["onLoad", "data"], be = (i, { data: e, onLoad: t, ...n }) => {
  e && i.load(e, n).then((o) => {
    t && t(o);
  });
}, wo = a({
  name: "CzmlDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const t = new Ze(e.name);
    return e.clustering && (t.clustering = e.clustering), typeof e.show == "boolean" && (t.show = e.show), i.dataSourceCollection.add(t), e.data && be(t, e), t;
  },
  update(i, e, t) {
    e.data ? t.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (t.data !== e.data || t.sourceUri !== e.sourceUri || t.credit !== e.credit) && be(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: mt,
  cesiumReadonlyProps: ht,
  cesiumEventProps: ft,
  otherProps: yt,
  useCommonEvent: !0
}), pt = [
  "semiMajorAxis",
  "semiMinorAxis",
  "height",
  "heightReference",
  "extrudedHeight",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "numberOfVerticalLines",
  "rotation",
  "stRotation",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType",
  "extrudedHeightReference"
], gt = {
  onDefinitionChange: "definitionChanged"
}, So = a({
  name: "EllipseGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Xe(e);
    return i.entity.ellipse = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.ellipse = void 0);
  },
  cesiumProps: pt,
  cesiumEventProps: gt
}), vt = [
  "heightReference",
  "radii",
  "show",
  "fill",
  "innerRadii",
  "material",
  "maximumClock",
  "maximumCone",
  "minimumClock",
  "minimumCone",
  "outline",
  "outlineColor",
  "outlineWidth",
  "subdivisions",
  "stackPartitions",
  "slicePartitions",
  "shadows",
  "distanceDisplayCondition"
], Ct = {
  onDefinitionChange: "definitionChanged"
}, bo = a({
  name: "EllipsoidGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Qe(e);
    return i.entity.ellipsoid = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.ellipsoid = void 0);
  },
  cesiumProps: vt,
  cesiumEventProps: Ct
}), Pt = [
  "availability",
  "billboard",
  "box",
  "corridor",
  "cylinder",
  "description",
  "ellipse",
  "ellipsoid",
  "entityCollection",
  "label",
  "model",
  "name",
  "orientation",
  "path",
  "plane",
  "parent",
  "point",
  "polygon",
  "polyline",
  "polylineVolume",
  "position",
  "properties",
  "rectangle",
  "show",
  "tileset",
  "trackingReferenceFrame",
  "viewFrom",
  "wall"
], Et = ["id"], wt = {
  onDefinitionChange: "definitionChanged"
}, St = ["selected", "tracked"], Do = a({
  name: "Entity",
  create(i, e) {
    if (!i.entityCollection)
      return;
    const t = new ei(e);
    return i.viewer && e.selected && (i.viewer.selectedEntity = t), i.viewer && e.tracked && (i.viewer.trackedEntity = t), i.entityCollection.add(t), t;
  },
  destroy(i, e) {
    e.entityCollection && e.entityCollection.remove(i);
  },
  update(i, e, t, n) {
    n.viewer && (e.selected !== t.selected && (e.selected ? n.viewer.selectedEntity = i : n.viewer.selectedEntity === i && (n.viewer.selectedEntity = void 0)), e.tracked !== t.tracked && (e.tracked ? n.viewer.trackedEntity = i : n.viewer.trackedEntity === i && (n.viewer.trackedEntity = void 0)));
  },
  provide(i, e, t) {
    return {
      entity: i,
      __$internal: {
        onUpdate: t == null ? void 0 : t.onUpdate
      }
    };
  },
  cesiumProps: Pt,
  cesiumReadonlyProps: Et,
  cesiumEventProps: wt,
  otherProps: St,
  useCommonEvent: !0
}), Ro = ({
  children: i,
  container: e,
  resizeInfoBox: t = !0
}) => {
  const { viewer: n, entity: o } = ae(), [s, l] = Me(!1), m = Ve(
    () => {
      var d;
      return e ?? ((d = n == null ? void 0 : n.infoBox.frame.contentDocument) == null ? void 0 : d.createElement("div"));
    },
    [e, n == null ? void 0 : n.infoBox.frame.contentDocument]
  );
  return K(() => {
    if (!n || !o)
      return;
    const d = (f) => {
      l(!!f && f.id === o.id);
    };
    return n.selectedEntityChanged.addEventListener(d), () => {
      n.selectedEntityChanged.removeEventListener(d);
    };
  }, [o, n]), K(() => {
    var D, T;
    if (e || !m || !n)
      return;
    const d = (D = n.infoBox) == null ? void 0 : D.frame, f = (T = d == null ? void 0 : d.contentDocument) == null ? void 0 : T.querySelector(".cesium-infoBox-description");
    if (!d || !f)
      return;
    let p;
    if (s) {
      if (t) {
        const h = f.getBoundingClientRect().height;
        d.style.height = h + "px", p = window.setInterval(() => {
          const E = n.infoBox.container.querySelector(
            ".cesium-infoBox.cesium-infoBox-visible"
          );
          E && (clearInterval(p), p = void 0, f.appendChild(m), E.classList.remove("cesium-infoBox-bodyless"), d.style.height = f.getBoundingClientRect().height + "px");
        }, 10);
      }
    } else
      m.parentElement === f && f.removeChild(m);
    return p ? () => clearTimeout(p) : void 0;
  }, [m, e, t, s, n]), m ? /* @__PURE__ */ A.jsx(A.Fragment, { children: Ri(/* @__PURE__ */ A.jsx(A.Fragment, { children: !e || s ? i : null }), m) }) : null;
}, bt = [
  "density",
  "enabled",
  "heightFalloff",
  "heightScalar",
  "maxHeight",
  "minimumBrightness",
  "renderable",
  "screenSpaceErrorFactor",
  "visualDensityScalar"
], To = a({
  name: "Fog",
  create(i) {
    if (!i.scene)
      return;
    const e = new ge();
    return i.scene.fog = e, e;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.fog = new ge());
  },
  cesiumProps: bt,
  setCesiumPropsAfterCreate: !0
}), Dt = ["clustering", "name", "show"], Rt = [
  "clampToGround",
  "sourceUri",
  "credit",
  "markerSize",
  "markerSymbol",
  "markerColor",
  "stroke",
  "strokeWidth",
  "fill",
  "describe"
], Tt = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, Mt = ["onLoad", "data"], De = (i, { data: e, onLoad: t, ...n }) => {
  e && i.load(e, n).then((o) => {
    t && t(o);
  });
}, Mo = a({
  name: "GeoJsonDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const t = new ii(e.name);
    return e.clustering && (t.clustering = e.clustering), typeof e.show == "boolean" && (t.show = e.show), i.dataSourceCollection.add(t), e.data && De(t, e), t;
  },
  update(i, e, t) {
    e.data ? t.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (t.data !== e.data || t.clampToGround !== e.clampToGround || t.sourceUri !== e.sourceUri || t.credit !== e.credit || t.markerSize !== e.markerSize || t.markerSymbol !== e.markerSymbol || t.markerColor !== e.markerColor || t.stroke !== e.stroke || t.strokeWidth !== e.strokeWidth || t.fill !== e.fill) && De(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: Dt,
  cesiumReadonlyProps: Rt,
  cesiumEventProps: Tt,
  otherProps: Mt,
  useCommonEvent: !0
}), kt = {
  onImageryLayersUpdate: "imageryLayersUpdatedEvent",
  onTerrainProviderChange: "terrainProviderChanged",
  onTileLoadProgress: "tileLoadProgressEvent"
}, $t = [
  "atmosphereBrightnessShift",
  "atmosphereHueShift",
  "atmosphereSaturationShift",
  "backFaceCulling",
  "baseColor",
  "clippingPlanes",
  "depthTestAgainstTerrain",
  "enableLighting",
  "lightingFadeInDistance",
  "lightingFadeOutDistance",
  "material",
  "maximumScreenSpaceError",
  "nightFadeInDistance",
  "nightFadeOutDistance",
  "oceanNormalMapUrl",
  "shadows",
  "show",
  "showGroundAtmosphere",
  "showWaterEffect",
  "tileCacheSize",
  "loadingDescendantLimit",
  "preloadAncestors",
  "preloadSiblings",
  "fillHighlightColor",
  "dynamicAtmosphereLighting",
  "dynamicAtmosphereLightingFromSun",
  "showSkirts",
  "cartographicLimitRectangle",
  "translucency",
  "undergroundColor",
  "undergroundColorAlphaByDistance",
  "lambertDiffuseMultiplier",
  "atmosphereLightIntensity",
  "atmosphereRayleighCoefficient",
  "atmosphereMieCoefficient",
  "atmosphereRayleighScaleHeight",
  "atmosphereMieScaleHeight",
  "atmosphereMieAnisotropy",
  "vertexShadowDarkness",
  "clippingPolygons"
], Lt = ["terrainProvider"], ko = a({
  name: "Globe",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.globe;
  },
  update: async (i, e) => {
    const t = e.terrainProvider;
    let n;
    F(t) ? n = await t : n = t, i.terrainProvider = n;
  },
  cesiumProps: $t,
  cesiumEventProps: kt,
  otherProps: Lt,
  setCesiumPropsAfterCreate: !0
}), $o = a({
  name: "Google2DImageryProvider",
  async create(i, e) {
    const { onReady: t, assetId: n, accessToken: o, key: s, children: l, ...m } = e;
    let d;
    if (n !== void 0) {
      const f = { ...m, assetId: n };
      o !== void 0 && (f.accessToken = o), d = await ve.fromIonAssetId(f);
    } else {
      const f = { ...m };
      s !== void 0 && (f.key = s), d = await ve.fromUrl(f);
    }
    return t && t(d), d;
  }
}), _t = [
  "appearance",
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], Ot = [
  "allowPicking",
  "asynchronous",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances"
], At = ["onReady"], Lo = a({
  name: "GroundPolylinePrimitive",
  create(i, e) {
    var n;
    if (!i.primitiveCollection)
      return;
    const t = new ti(e);
    if (e.onReady) {
      const o = () => {
        var s, l;
        t.ready && ((s = e.onReady) == null || s.call(e, t), (l = i.scene) == null || l.postRender.removeEventListener(o));
      };
      (n = i.scene) == null || n.postRender.addEventListener(o);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: _t,
  cesiumReadonlyProps: Ot,
  otherProps: At,
  useCommonEvent: !0
}), Bt = [
  "appearance",
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], Gt = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize"
], It = ["onReady"], _o = a({
  name: "GroundPrimitive",
  create(i, e) {
    var n;
    if (!i.primitiveCollection)
      return;
    const t = new ni(e);
    if (e.onReady) {
      const o = () => {
        var s, l;
        t.ready && ((s = e.onReady) == null || s.call(e, t), (l = i.scene) == null || l.postRender.removeEventListener(o));
      };
      (n = i.scene) == null || n.postRender.addEventListener(o);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Bt,
  cesiumReadonlyProps: Gt,
  otherProps: It,
  useCommonEvent: !0
}), Ft = ["show", "destroyPrimitives", "primitiveAdded", "primitiveRemoved"], Oo = a({
  name: "GroundPrimitiveCollection",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.groundPrimitives;
  },
  provide: (i) => ({
    primitiveCollection: i
  }),
  cesiumProps: Ft,
  setCesiumPropsAfterCreate: !0
}), Vt = [
  "alpha",
  "brightness",
  "contrast",
  "hue",
  "saturation",
  "gamma",
  "splitDirection",
  "minificationFilter",
  "magnificationFilter",
  "cutoutRectangle",
  "show",
  "nightAlpha",
  "dayAlpha",
  "colorToAlpha",
  "colorToAlphaThreshold",
  "index"
], Ut = [
  "rectangle",
  "maximumAnisotropy",
  "minimumTerrainLevel",
  "maximumTerrainLevel",
  "imageryProvider"
], Ao = a({
  name: "ImageryLayer",
  async create(i, e) {
    var l, m, d, f;
    if (!i.imageryLayerCollection)
      return;
    const t = F(e.imageryProvider) ? e.imageryProvider : new Promise((p) => queueMicrotask(() => p(e.imageryProvider))), n = (m = (l = i.__$internal) == null ? void 0 : l.imageryLayerWaitingList) == null ? void 0 : m.slice();
    (d = i.__$internal) != null && d.imageryLayerWaitingList && i.__$internal.imageryLayerWaitingList.push(t), n && await Promise.all(n.filter((p) => F(p)));
    const o = await t;
    if ((f = i.__$internal) != null && f.imageryLayerWaitingList && (i.__$internal.imageryLayerWaitingList = i.__$internal.imageryLayerWaitingList.filter((p) => p !== t)), !o)
      return;
    const s = new oi(o, e);
    return i.imageryLayerCollection.add(s, e.index), s;
  },
  destroy(i, e) {
    e.imageryLayerCollection && e.imageryLayerCollection.remove(i);
  },
  cesiumProps: Vt,
  cesiumReadonlyProps: Ut
}), Wt = {
  onLayerAdd: "layerAdded",
  onLayerMove: "layerMoved",
  onLayerRemove: "layerRemoved",
  onLayerShowOrHide: "layerShownOrHidden"
}, Bo = a({
  name: "ImageryLayerCollection",
  create: (i) => {
    var e;
    return (e = i.globe) == null ? void 0 : e.imageryLayers;
  },
  cesiumEventProps: Wt
}), jt = ["clustering", "name", "show"], Ht = [
  "canvas",
  "camera",
  "ellipsoid",
  "clampToGround",
  "sourceUri",
  "credit",
  "screenOverlayContainer"
], Nt = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent",
  onRefresh: "refreshEvent",
  onUnsupportedNode: "unsupportedNodeEvent"
}, zt = ["onLoad", "data"], Re = (i, { data: e, onLoad: t, ...n }) => {
  e && i.load(e, n).then((o) => {
    t && t(o);
  });
}, Go = a({
  name: "KmlDataSource",
  create(i, e) {
    if (!i.scene || !i.dataSourceCollection || !i.scene)
      return;
    const t = new ri({
      camera: e.camera || i.scene.camera,
      canvas: e.canvas || i.scene.canvas,
      ellipsoid: e.ellipsoid,
      credit: e.credit
    });
    return e.clustering && (t.clustering = e.clustering), typeof e.show == "boolean" && (t.show = e.show), typeof e.name < "u" && (t.name = e.name), i.dataSourceCollection.add(t), e.data && Re(t, e), t;
  },
  update(i, e, t) {
    e.data ? t.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (t.data !== e.data || t.clampToGround !== e.clampToGround || t.ellipsoid !== e.ellipsoid || t.sourceUri !== e.sourceUri || t.credit !== e.credit) && Re(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: jt,
  cesiumReadonlyProps: Ht,
  cesiumEventProps: Nt,
  otherProps: zt,
  useCommonEvent: !0
}), xt = [
  "backgroundColor",
  "backgroundPadding",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "eyeOffset",
  "fillColor",
  "font",
  "heightReference",
  "horizontalOrigin",
  "id",
  "outlineColor",
  "outlineWidth",
  "pixelOffset",
  "pixelOffsetScaleByDistance",
  "position",
  "scale",
  "scaleByDistance",
  "show",
  "showBackground",
  "style",
  "text",
  "translucencyByDistance",
  "verticalOrigin"
], Io = a({
  name: "Label",
  create: (i, e) => {
    var t;
    return (t = i.labelCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.labelCollection && !e.labelCollection.isDestroyed() && e.labelCollection.remove(i);
  },
  cesiumProps: xt,
  useCommonEvent: !0
}), qt = ["blendOption", "debugShowBoundingVolume", "modelMatrix", "show"], Fo = a({
  name: "LabelCollection",
  create(i, e) {
    if (!i.scene || !i.primitiveCollection)
      return;
    const t = new si({
      scene: i.scene,
      modelMatrix: e.modelMatrix,
      blendOption: e.blendOption,
      debugShowBoundingVolume: e.debugShowBoundingVolume
    });
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      labelCollection: i
    };
  },
  cesiumProps: qt
}), Yt = [
  "text",
  "font",
  "style",
  "fillColor",
  "outlineColor",
  "outlineWidth",
  "show",
  "showBackground",
  "backgroundColor",
  "backgroundPadding",
  "scale",
  "horizontalOrigin",
  "verticalOrigin",
  "eyeOffset",
  "pixelOffset",
  "translucencyByDistance",
  "pixelOffsetScaleByDistance",
  "scaleByDistance",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance"
], Kt = {
  onDefinitionChange: "definitionChanged"
}, Vo = a({
  name: "LabelGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new ai(e);
    return i.entity.label = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.label = void 0);
  },
  cesiumProps: Yt,
  cesiumEventProps: Kt
}), Jt = [
  "backFaceCulling",
  "clampAnimations",
  "clippingPlanes",
  "clippingPolygons",
  "color",
  "colorBlendAmount",
  "colorBlendMode",
  "customShader",
  "debugShowBoundingVolume",
  "debugWireframe",
  "distanceDisplayCondition",
  "enableVerticalExaggeration",
  "featureIdLabel",
  "heightReference",
  "id",
  "imageBasedLighting",
  "instanceFeatureIdLabel",
  "lightColor",
  "maximumScale",
  "minimumPixelSize",
  "modelMatrix",
  "outlineColor",
  "scale",
  "shadows",
  "show",
  "showCreditsOnScreen",
  "showOutline",
  "silhouetteColor",
  "silhouetteSize",
  "splitDirection",
  "style",
  "pointCloudShading"
], Zt = [
  "allowPicking",
  "asynchronous",
  "basePath",
  "credit",
  "enableDebugWireframe",
  "gltf",
  "incrementallyLoadTextures",
  "scene",
  "releaseGltfJson",
  "cull",
  "opaquePass",
  "upAxis",
  "forwardAxis",
  "content",
  "enableShowOutline",
  "projectTo2D",
  "classificationType",
  "gltfCallback",
  "enablePick",
  "environmentMapOptions"
], Xt = ["onReady", "onError", "url"], Uo = a({
  name: "Model",
  async create(i, { scene: e, url: t, colorBlendMode: n, ...o }) {
    var d;
    if (!i.scene || !i.primitiveCollection || !t)
      return;
    const s = t;
    let l;
    F(s) ? l = await s : l = s;
    let m;
    try {
      m = await li.fromGltfAsync({
        ...o,
        url: l,
        colorBlendMode: n,
        scene: e || i.scene
      });
    } catch (f) {
      (d = o.onError) == null || d.call(o, f);
      return;
    }
    return i.primitiveCollection.add(m), m;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumEventProps: {
    onReady: "readyEvent"
  },
  cesiumProps: Jt,
  cesiumReadonlyProps: Zt,
  otherProps: Xt,
  useCommonEvent: !0
}), Qt = [
  "uri",
  "show",
  "scale",
  "minimumPixelSize",
  "maximumScale",
  "incrementallyLoadTextures",
  "runAnimations",
  "clampAnimations",
  "nodeTransformations",
  "shadows",
  "heightReference",
  "distanceDisplayCondition",
  "silhouetteColor",
  "silhouetteSize",
  "color",
  "colorBlendMode",
  "colorBlendAmount",
  "clippingPlanes",
  "imageBasedLightingFactor",
  "lightColor",
  "articulations",
  "customShader",
  "enableVerticalExaggeration",
  "environmentMapOptions"
], en = {
  onDefinitionChange: "definitionChanged"
}, Wo = a({
  name: "ModelGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new ci(e);
    return i.entity.model = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.model = void 0);
  },
  cesiumProps: Qt,
  cesiumEventProps: en
}), tn = ["onlySunLighting", "show", "textureUrl"], nn = ["ellipsoid"], jo = a({
  name: "Moon",
  create(i, e) {
    if (!i.scene)
      return;
    const t = new Ce(e);
    return i.scene.moon = t, t;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.moon = new Ce());
  },
  cesiumProps: tn,
  cesiumReadonlyProps: nn
}), on = [
  "show",
  "emitter",
  "modelMatrix",
  "emitterModelMatrix",
  "emissionRate",
  "bursts",
  "loop",
  "startScale",
  "endScale",
  "startColor",
  "endColor",
  "image",
  "imageSize",
  "minimumImageSize",
  "maximumImageSize",
  "speed",
  "minimumSpeed",
  "maximumSpeed",
  "lifetime",
  "particleLife",
  "minimumParticleLife",
  "maximumParticleLife",
  "mass",
  "minimumMass",
  "maximumMass",
  "sizeInMeters"
], rn = {
  onComplete: "complete",
  onUpdate: "updateCallback"
}, Ho = a({
  name: "ParticleSystem",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const t = new ui({
      ...e,
      updateCallback: e.onUpdate
    });
    return i.primitiveCollection.add(t), t;
  },
  update(i, e, t) {
    e.onUpdate !== t.onUpdate && (i.updateCallback = e.onUpdate);
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i);
  },
  cesiumProps: on,
  cesiumEventProps: rn
}), sn = [
  "leadTime",
  "trailTime",
  "show",
  "width",
  "material",
  "resolution",
  "distanceDisplayCondition"
], an = {
  onDefinitionChange: "definitionChanged"
}, No = a({
  name: "PathGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new di(e);
    return i.entity.path = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.path = void 0);
  },
  cesiumProps: sn,
  cesiumEventProps: an
}), ln = [
  "plane",
  "dimensions",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "shadows",
  "distanceDisplayCondition"
], cn = {
  onDefinitionChange: "definitionChanged"
}, zo = a({
  name: "PlaneGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new mi(e);
    return i.entity.plane = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.plane = void 0);
  },
  cesiumProps: ln,
  cesiumEventProps: cn
}), un = [
  "color",
  "pixelSize",
  "outlineColor",
  "outlineWidth",
  "show",
  "scaleByDistance",
  "translucencyByDistance",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance",
  "splitDirection"
], dn = {
  onDefinitionChange: "definitionChanged"
}, xo = a({
  name: "PointGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new hi(e);
    return i.entity.point = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.point = void 0);
  },
  cesiumProps: un,
  cesiumEventProps: dn
}), mn = [
  "color",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "id",
  "outlineColor",
  "outlineWidth",
  "pixelSize",
  "position",
  "scaleByDistance",
  "show",
  "splitDirection",
  "translucencyByDistance"
], qo = a({
  name: "PointPrimitive",
  create: (i, e) => {
    var t;
    return (t = i.pointPrimitiveCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.pointPrimitiveCollection && !e.pointPrimitiveCollection.isDestroyed() && e.pointPrimitiveCollection.remove(i);
  },
  cesiumProps: mn,
  useCommonEvent: !0
}), hn = ["blendOption", "debugShowBoundingVolume", "modelMatrix", "show"], Yo = a({
  name: "PointPrimitveCollection",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const t = new fi(e);
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      pointPrimitiveCollection: i
    };
  },
  cesiumProps: hn
}), fn = [
  "arcType",
  "hierarchy",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "stRotation",
  "granularity",
  "perPositionHeight",
  "closeTop",
  "closeBottom",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType",
  "textureCoordinates"
], yn = {
  onDefinitionChange: "definitionChanged"
}, Ko = a({
  name: "PolygonGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new yi(e);
    return i.entity.polygon = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.polygon = void 0);
  },
  cesiumProps: fn,
  cesiumEventProps: yn
}), pn = [
  "distanceDisplayCondition",
  "id",
  "loop",
  "material",
  "positions",
  "show",
  "width"
], Jo = a({
  name: "Polyline",
  create: (i, e) => {
    var t;
    return (t = i.polylineCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.polylineCollection && !e.polylineCollection.isDestroyed() && e.polylineCollection.remove(i);
  },
  cesiumProps: pn,
  useCommonEvent: !0
}), gn = ["debugShowBoundingVolume", "length", "modelMatrix", "show"], Zo = a(
  {
    name: "PolylineCollection",
    create(i, e) {
      if (!i.primitiveCollection)
        return;
      const t = new pi({
        modelMatrix: e.modelMatrix,
        debugShowBoundingVolume: e.debugShowBoundingVolume,
        length: e.length,
        scene: i.scene
      });
      return i.primitiveCollection.add(t), t;
    },
    destroy(i, e) {
      e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
    },
    provide(i) {
      return {
        polylineCollection: i
      };
    },
    cesiumProps: gn
  }
), vn = [
  "arcType",
  "classificationType",
  "positions",
  "clampToGround",
  "width",
  "show",
  "material",
  "depthFailMaterial",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex"
], Cn = {
  onDefinitionChange: "definitionChanged"
}, Xo = a({
  name: "PolylineGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new gi(e);
    return i.entity.polyline = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.polyline = void 0);
  },
  cesiumProps: vn,
  cesiumEventProps: Cn
}), Pn = [
  "positions",
  "shape",
  "cornerType",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition"
], En = {
  onDefinitionChange: "definitionChanged"
}, Qo = a({
  name: "PolylineVolumeGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new vi(e);
    return i.entity.polylineVolume = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.polylineVolume = void 0);
  },
  cesiumProps: Pn,
  cesiumEventProps: En
}), wn = ["enabled", "selected"], Sn = [
  "clearColor",
  "forcePowerOfTwo",
  "fragmentShader",
  "name",
  "pixelDatatype",
  "pixelFormat",
  "sampleMode",
  "scissorRectangle",
  "textureScale",
  "uniforms"
], er = a({
  name: "PostProcessStage",
  create(i, e) {
    if (!i.scene)
      return;
    const t = new Ci(e);
    return typeof e.enabled == "boolean" && (t.enabled = e.enabled), e.selected && (t.selected = e.selected), i.scene.postProcessStages.add(t), t;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: wn,
  cesiumReadonlyProps: Sn
}), ir = $({
  name: "BlackAndWhiteStage",
  props: ["gradations"],
  create: () => V.createBlackAndWhiteStage()
}), tr = $({
  name: "BrightnessStage",
  props: ["brightness"],
  create: () => V.createBrightnessStage()
}), nr = $({
  name: "LensFlareStage",
  props: [
    "dirtTexture",
    "starTexture",
    "intensity",
    "distortion",
    "ghostDispersal",
    "haloWidth",
    "earthRadius"
  ],
  create: () => V.createLensFlareStage()
}), or = $({
  name: "Fxaa",
  create: (i, e) => e.fxaa,
  props: []
}), rr = $({
  name: "NightVisionStage",
  props: [],
  create: () => V.createNightVisionStage()
}), bn = ["enabled", "selected"], Dn = ["inputPreviousStageTexture", "name", "stages", "uniforms"], sr = a({
  name: "PostProcessStageComposite",
  create(i, e) {
    if (!i.scene)
      return;
    const t = new Pi(e);
    return typeof e.enabled == "boolean" && (t.enabled = e.enabled), e.selected && (t.selected = e.selected), i.scene.postProcessStages.add(t), t;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: bn,
  cesiumReadonlyProps: Dn
}), ar = $({
  name: "AmbientOcclusion",
  create: (i, e) => e.ambientOcclusion,
  props: [
    "ambientOcclusionOnly",
    "bias",
    "delta",
    "frustumLength",
    "intensity",
    "lengthCap",
    "sigma",
    "stepSize"
  ],
  noMount: !0
}), lr = $({
  name: "Bloom",
  create: (i, e) => e.bloom,
  props: ["brightness", "contrast", "delta", "glowOnly", "sigma", "stepSize"],
  noMount: !0
}), cr = $({
  name: "BlurStage",
  props: ["delta", "sigma", "stepSize"],
  create: () => V.createBlurStage()
}), ur = $({
  name: "DepthOfFieldStage",
  props: ["delta", "focalDistance", "sigma", "stepSize"],
  create: () => V.createDepthOfFieldStage()
}), dr = $({
  name: "EdgeDetectionStage",
  props: ["color", "length"],
  create: () => V.createEdgeDetectionStage()
}), mr = $({
  name: "SilhouetteStage",
  props: ["color", "length"],
  create: () => V.createSilhouetteStage()
}), Rn = [
  "appearance",
  "cull",
  "debugShowBoundingVolume",
  "depthFailAppearance",
  "modelMatrix",
  "shadows",
  "show"
], Tn = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize"
], Mn = ["onReady"], hr = a({
  name: "Primitive",
  create(i, e) {
    var n;
    if (!i.primitiveCollection)
      return;
    const t = new Ei(e);
    if (e.onReady) {
      const o = () => {
        var s, l;
        t.ready && ((s = e.onReady) == null || s.call(e, t), (l = i.scene) == null || l.postRender.removeEventListener(o));
      };
      (n = i.scene) == null || n.postRender.addEventListener(o);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Rn,
  cesiumReadonlyProps: Tn,
  otherProps: Mn,
  useCommonEvent: !0
}), kn = [
  "classificationType",
  "coordinates",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "rotation",
  "stRotation",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex"
], $n = {
  onDefinitionChange: "definitionChanged"
}, fr = a({
  name: "RectangleGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new wi(e);
    return i.entity.rectangle = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.rectangle = void 0);
  },
  cesiumProps: kn,
  cesiumEventProps: $n
}), Ln = [
  "backgroundColor",
  "completeMorphOnUserInput",
  // "debugCommandFilter", // Ignored in type check
  "debugShowCommands",
  "debugShowDepthFrustum",
  "debugShowFramesPerSecond",
  "debugShowFrustumPlanes",
  "debugShowFrustums",
  "eyeSeparation",
  "farToNearRatio",
  "focalLength",
  "fog",
  "gamma",
  "globe",
  "highDynamicRange",
  "invertClassification",
  "invertClassificationColor",
  "light",
  "logarithmicDepthBuffer",
  "logarithmicDepthFarToNearRatio",
  "maximumRenderTimeChange",
  "minimumDisableDepthTestDistance",
  // "mode", // enable morph with animation
  "moon",
  "morphTime",
  "nearToFarDistance2D",
  "pickTranslucentDepth",
  "requestRenderMode",
  "rethrowRenderErrors",
  "shadowMap",
  "skyAtmosphere",
  "skyBox",
  "specularEnvironmentMaps",
  "sphericalHarmonicCoefficients",
  "sun",
  "sunBloom",
  "terrainProvider",
  "useDepthPicking",
  "useWebVR",
  // "postProcessStages", // Ignored in type check - readonly property
  "msaaSamples",
  "splitPosition",
  "verticalExaggeration",
  "verticalExaggerationRelativeHeight",
  "atmosphere"
], _n = {
  onMorphComplete: "morphComplete",
  onMorphStart: "morphStart",
  onPostRender: "postRender",
  onPreRender: "preRender",
  onPreUpdate: "preUpdate",
  onPostUpdate: "postUpdate",
  onRenderError: "renderError",
  onTerrainProviderChange: "terrainProviderChanged"
}, On = ["mode", "morphDuration", "enableEdgeVisibility"], Te = (i, e, t) => {
  switch (e) {
    case ue.SCENE2D:
      i.morphTo2D(t);
      break;
    case ue.COLUMBUS_VIEW:
      i.morphToColumbusView(t);
      break;
    case ue.SCENE3D:
      i.morphTo3D(t);
      break;
  }
}, yr = a({
  name: "Scene",
  create(i, e) {
    return i.scene && (e.mode && Te(i.scene, e.mode, e.morphDuration), e.enableEdgeVisibility !== void 0 && (i.scene._enableEdgeVisibility = e.enableEdgeVisibility)), i.scene;
  },
  update(i, e, t) {
    e.mode !== t.mode && e.mode && Te(i, e.mode, e.morphDuration), e.enableEdgeVisibility !== t.enableEdgeVisibility && e.enableEdgeVisibility !== void 0 && (i._enableEdgeVisibility = e.enableEdgeVisibility);
  },
  cesiumProps: Ln,
  cesiumEventProps: _n,
  otherProps: On,
  setCesiumPropsAfterCreate: !0
}), An = [
  "bounceAnimationTime",
  "enableCollisionDetection",
  "enableInputs",
  "enableLook",
  "enableRotate",
  "enableTilt",
  "enableTranslate",
  "enableZoom",
  "inertiaSpin",
  "inertiaTranslate",
  "inertiaZoom",
  "lookEventTypes",
  "maximumMovementRatio",
  "maximumZoomDistance",
  "minimumCollisionTerrainHeight",
  "minimumPickingTerrainHeight",
  "minimumTrackBallHeight",
  "minimumZoomDistance",
  "rotateEventTypes",
  "tiltEventTypes",
  "translateEventTypes",
  "zoomEventTypes",
  "minimumPickingTerrainDistanceWithInertia",
  "maximumTiltAngle",
  "zoomFactor"
], pr = a({
  name: "ScreenSpaceCameraController",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.screenSpaceCameraController;
  },
  cesiumProps: An,
  setCesiumPropsAfterCreate: !0
}), gr = ({ action: i, modifier: e, type: t }) => {
  const n = ae();
  return K(() => {
    if (!(!n.screenSpaceEventHandler || n.screenSpaceEventHandler.isDestroyed())) {
      if (i)
        return n.screenSpaceEventHandler.setInputAction(i, t, e), () => {
          !n.screenSpaceEventHandler || n.screenSpaceEventHandler.isDestroyed() || n.screenSpaceEventHandler.removeInputAction(t, e);
        };
      n.screenSpaceEventHandler.removeInputAction(t, e);
    }
  }, [i, n.screenSpaceEventHandler, e, t]), null;
}, vr = a({
  name: "ScreenSpaceEventHandler",
  create(i, e) {
    var t;
    return e.useDefault ? (t = i.cesiumWidget) == null ? void 0 : t.screenSpaceEventHandler : i.scene ? new $e(i.scene.canvas) : void 0;
  },
  destroy(i) {
    i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      screenSpaceEventHandler: i
    };
  }
}), Bn = [
  "darkness",
  "fadingEnabled",
  "maximumDistance",
  "enabled",
  "normalOffset",
  "softShadows",
  "size"
], Cr = a({
  name: "ShadowMap",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.shadowMap;
  },
  cesiumProps: Bn
}), Gn = [
  "brightnessShift",
  "hueShift",
  "saturationShift",
  "show",
  "perFragmentAtmosphere",
  "atmosphereLightIntensity",
  "atmosphereRayleighCoefficient",
  "atmosphereMieCoefficient",
  "atmosphereRayleighScaleHeight",
  "atmosphereMieScaleHeight",
  "atmosphereMieAnisotropy"
], Pr = a({
  name: "SkyAtmosphere",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.skyAtmosphere;
  },
  cesiumProps: Gn,
  setCesiumPropsAfterCreate: !0
}), In = ["sources", "show"], Er = a({
  name: "SkyBox",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.skyBox;
  },
  cesiumProps: In,
  setCesiumPropsAfterCreate: !0
}), Fn = ["glowFactor", "show"], wr = a({
  name: "Sun",
  create(i) {
    if (!i.scene)
      return;
    const e = new Pe();
    return i.scene.sun = e, e;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.sun = new Pe());
  },
  cesiumProps: Fn,
  setCesiumPropsAfterCreate: !0
}), Vn = [
  "clippingPlanes",
  "maximumMemoryUsage",
  "modelMatrix",
  "shadows",
  "show",
  "style",
  "intervals"
], Un = ["clock", "shading"], Wn = ["onReady"], jn = {
  onFrameChange: "frameChanged"
}, Sr = a({
  name: "TimeDynamicPointCloud",
  create(i, e) {
    var n;
    if (!i.cesiumWidget || !i.primitiveCollection || !((n = i.cesiumWidget) != null && n.clock))
      return;
    const t = new Si({
      ...e,
      clock: e.clock ?? i.cesiumWidget.clock
    });
    if (e.onReady) {
      const o = () => {
        var s;
        (s = e.onReady) == null || s.call(e, t), t.frameChanged.removeEventListener(o);
      };
      t.frameChanged.addEventListener(o);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Vn,
  cesiumReadonlyProps: Un,
  cesiumEventProps: jn,
  otherProps: Wn,
  useCommonEvent: !0
}), Hn = [
  "terrainShadows",
  "clockTrackedDataSource",
  "targetFrameRate",
  "useDefaultRenderLoop",
  "resolutionScale",
  "allowDataSourcesToSuspendAnimation",
  "trackedEntity",
  "selectedEntity",
  "shadows",
  "useBrowserRecommendedResolution",
  "creditDisplay"
], Nn = [
  "baseLayer",
  "animation",
  "baseLayerPicker",
  "fullscreenButton",
  "vrButton",
  "geocoder",
  "homeButton",
  "infoBox",
  "sceneModePicker",
  "selectionIndicator",
  "timeline",
  "navigationHelpButton",
  "navigationInstructionsInitiallyVisible",
  "scene3DOnly",
  "shouldAnimate",
  "clockViewModel",
  "selectedImageryProviderViewModel",
  "imageryProviderViewModels",
  "selectedTerrainProviderViewModel",
  "terrainProviderViewModels",
  "ellipsoid",
  "skyBox",
  "skyAtmosphere",
  "fullscreenElement",
  "showRenderLoopErrors",
  "automaticallyTrackDataSourceClocks",
  "contextOptions",
  "sceneMode",
  "mapProjection",
  "globe",
  "orderIndependentTranslucency",
  "creditContainer",
  "creditViewport",
  "dataSources",
  "mapMode2D",
  "projectionPicker",
  "blurActiveElementOnCanvasFocus",
  "requestRenderMode",
  "maximumRenderTimeChange",
  "depthPlaneEllipsoidOffset",
  "msaaSamples",
  "terrain"
], zn = {
  onSelectedEntityChange: "selectedEntityChanged",
  onTrackedEntityChange: "trackedEntityChanged"
}, xn = [
  "className",
  "id",
  "style",
  "full",
  "containerProps",
  "extend",
  "terrainProvider"
], br = a({
  name: "Viewer",
  async create(i, { baseLayer: e, terrainProvider: t, ...n }, o) {
    if (!o)
      return;
    let s;
    F(t) ? s = await t : s = t;
    const l = new bi(o, {
      ...n,
      terrainProvider: s,
      baseLayer: e ?? void 0
    });
    if (!l)
      return;
    e === !1 && l.imageryLayers.removeAll(), l && n.extend && (Array.isArray(n.extend) ? n.extend.forEach((d) => {
      l.extend(d, {});
    }) : l.extend(n.extend, {}));
    const m = new re(l.scene);
    return [l, m];
  },
  destroy(i, e, t, n) {
    n && !n.isDestroyed() && n.destroy(), i.isDestroyed() || i.destroy();
  },
  provide(i, e, t, n) {
    return {
      viewer: i,
      cesiumWidget: i.cesiumWidget,
      dataSourceCollection: i.dataSources,
      entityCollection: i.entities,
      scene: i.scene,
      camera: i.scene.camera,
      imageryLayerCollection: i.scene.globe.imageryLayers,
      primitiveCollection: i.scene.primitives,
      globe: i.scene.globe,
      __$internal: {
        onUpdate: t == null ? void 0 : t.onUpdate,
        imageryLayerWaitingList: []
      },
      [Y]: n
    };
  },
  containerProps: ({ id: i, className: e, style: t, full: n, containerProps: o }) => ({
    className: e,
    id: i,
    style: {
      ...n ? {
        position: "absolute",
        bottom: "0",
        left: "0",
        right: "0",
        top: "0"
      } : {},
      ...t
    },
    ...o
  }),
  cesiumProps: Hn,
  cesiumReadonlyProps: Nn,
  cesiumEventProps: zn,
  otherProps: xn,
  renderContainer: !0,
  useCommonEvent: !0,
  useRootEvent: !0
}), qn = [
  "positions",
  "maximumHeights",
  "minimumHeights",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition"
], Yn = {
  onDefinitionChange: "definitionChanged"
}, Dr = a({
  name: "WallGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Di(e);
    return i.entity.wall = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.wall = void 0);
  },
  cesiumProps: qn,
  cesiumEventProps: Yn
});
export {
  ar as AmbientOcclusion,
  io as Billboard,
  to as BillboardCollection,
  no as BillboardGraphics,
  ir as BlackAndWhiteStage,
  lr as Bloom,
  cr as BlurStage,
  oo as BoxGraphics,
  tr as BrightnessStage,
  ro as Camera,
  so as CameraFlyHome,
  ao as CameraFlyTo,
  co as CameraFlyToBoundingSphere,
  lo as CameraLookAt,
  ho as Cesium3DTilesTerrainProvider,
  uo as Cesium3DTileset,
  mo as Cesium3DTilesetGraphics,
  fe as CesiumContext,
  fo as CesiumWidget,
  yo as ClassificationPrimitive,
  po as Clock,
  go as CloudCollection,
  Ti as Consumer,
  vo as CorridorGraphics,
  Co as CumulusCloud,
  Po as CustomDataSource,
  Eo as CylinderGraphics,
  wo as CzmlDataSource,
  ur as DepthOfFieldStage,
  dr as EdgeDetectionStage,
  So as EllipseGraphics,
  bo as EllipsoidGraphics,
  Do as Entity,
  Ro as EntityDescription,
  re as EventManager,
  To as Fog,
  or as Fxaa,
  Mo as GeoJsonDataSource,
  ko as Globe,
  $o as Google2DImageryProvider,
  Lo as GroundPolylinePrimitive,
  _o as GroundPrimitive,
  Oo as GroundPrimitiveCollection,
  Ao as ImageryLayer,
  Bo as ImageryLayerCollection,
  Go as KmlDataSource,
  Io as Label,
  Fo as LabelCollection,
  Vo as LabelGraphics,
  nr as LensFlareStage,
  Uo as Model,
  Wo as ModelGraphics,
  jo as Moon,
  rr as NightVisionStage,
  Ho as ParticleSystem,
  No as PathGraphics,
  zo as PlaneGraphics,
  xo as PointGraphics,
  qo as PointPrimitive,
  Yo as PointPrimitiveCollection,
  Ko as PolygonGraphics,
  Jo as Polyline,
  Zo as PolylineCollection,
  Xo as PolylineGraphics,
  Qo as PolylineVolumeGraphics,
  er as PostProcessStage,
  sr as PostProcessStageComposite,
  hr as Primitive,
  Qn as Provider,
  fr as RectangleGraphics,
  yr as Scene,
  pr as ScreenSpaceCameraController,
  gr as ScreenSpaceEvent,
  vr as ScreenSpaceEventHandler,
  Cr as ShadowMap,
  mr as SilhouetteStage,
  Pr as SkyAtmosphere,
  Er as SkyBox,
  wr as Sun,
  Sr as TimeDynamicPointCloud,
  br as Viewer,
  Dr as WallGraphics,
  le as createCameraOperation,
  a as createCesiumComponent,
  $ as createPostProcessStage,
  me as entries,
  Y as eventManagerContextKey,
  he as eventNames,
  te as includes,
  _i as isDestroyable,
  Oi as isDestroyed,
  F as isPromise,
  $i as pick,
  Li as shallowEquals,
  ae as useCesium,
  Ai as useCesiumComponent,
  eo as withCesium
};
